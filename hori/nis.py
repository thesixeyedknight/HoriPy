#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
hori/nis.py

The NIS v2.0 (CDF) PRODUCTION Scoring Engine for HoriPy.

This module loads the single, definitive CDF pack generated by
the 'build_production_cdf.py' script and provides the main
'get_nis_score' function to score interactions.
"""

import json
import gzip
import hashlib
import numpy as np
from dataclasses import dataclass
from pathlib import Path
import sys
from typing import Dict, Optional, Any, List, TYPE_CHECKING

# --- Type Hint Imports ---
try:
    from hori.kbp_tools import KBPManager
    _kbp_import_error: Optional[ImportError] = None
except ImportError as e:
    KBPManager = None  # type: ignore[assignment]
    _kbp_import_error = e

if TYPE_CHECKING:
    from hori.kbp_tools import KBPManager as KBPManagerType
else:
    KBPManagerType = Any


__all__ = ['get_nis_score', 'HoriNIS']


# --- NIS v2.0 Dataclass (Production) ---

@dataclass
class HoriNIS:
    """
    Dataclass holding the complete NIS v2.0 (CDF) score and provenance.
    (Production version: fold_id has been removed).
    """
    nis_score: float
    s_phys: float
    s_kbp: float
    nis_mode: str
    alpha_used: float
    kbp_components_used: int
    cdf_hash: str
    kbp_npz_hash: str


# --- Global State: Load Artifacts on Import ---

try:
    # Find data files relative to this script's location
    # (hori/nis.py -> <project_root>/data/)
    _HORI_NIS_PY_PATH = Path(__file__).resolve()
    _PROJECT_ROOT = _HORI_NIS_PY_PATH.parent.parent
    _DATA_DIR = _PROJECT_ROOT / "data"
    
    # --- THIS IS THE NEW PRODUCTION FILE ---
    _CDF_PACK_PATH = _DATA_DIR / "nis_cdf_pack_v2_production.json.gz"

    # Load gzipped CDF pack
    with gzip.open(_CDF_PACK_PATH, 'rt', encoding='utf-8') as f:
        _CDF_DATA = json.load(f)

    # Store global constants from the single production pack
    CDF_PACK: Dict[str, Dict]     = _CDF_DATA["cdf_pack"] # The single pack
    P_GRID: np.ndarray             = np.array(_CDF_DATA["p_grid"], dtype=np.float32)
    KBP_SCHEMA: Dict[str, Dict]    = _CDF_DATA["kbp_schema"]
    PROVENANCE: Dict[str, Any]     = _CDF_DATA["provenance"]
    
    _CDF_BUILD_HASH: str = PROVENANCE["cdf_build_hash"]
    _KBP_NPZ_HASH: str = PROVENANCE["kbp_npz_hash"]
    _NIS_MODE: str     = _CDF_DATA["nis_mode"]

except Exception as e:
    print("="*80, file=sys.stderr)
    print("FATAL ERROR: HoriPy NIS v2.0 could not load PRODUCTION scoring artifact.", file=sys.stderr)
    print(f"Failed to load: {_CDF_PACK_PATH}", file=sys.stderr)
    print(f"Error: {e}", file=sys.stderr)
    print("Please run 'scripts/build_production_cdf.py' first.", file=sys.stderr)
    print("="*80, file=sys.stderr)
    # Re-raise to halt execution
    raise


# --- Core Logic Functions ---

def score_from_cdf(x: float, q: np.ndarray, p: np.ndarray) -> float:
    """
    Calculates a normalized score (0-1) from an empirical CDF.
    
    This function performs edge-safe linear interpolation to find the
    percentile rank of the measured value 'x', and then inverts it
    so that "good" (low) values get high scores.

    Args:
        x: The measured value (e.g., energy, distance).
        q: The quantile values (x-axis of CDF, sorted).
        p: The probability values (y-axis of CDF, 0.001 to 0.999).

    Returns:
        A float score from 0.0 to 1.0.
    """
    # 1. Find the percentile rank of x.
    #    np.interp is edge-safe: values of x outside the range of q
    #    will be clamped to the min/max p (0.001 or 0.999).
    percentile_rank = np.interp(x, q, p)
    
    # 2. Invert the score.
    #    A "good" value (low energy) will have a low percentile_rank
    #    (e.g., 0.001) and should get a high score (e.g., 0.999).
    return 1.0 - percentile_rank


# --- Main Scorer Function ---

def get_nis_score(
    itype: str,
    phys_energy: Optional[float],
    kbp_geom_metrics: Dict[str, float],
    kbp_manager: KBPManagerType
) -> HoriNIS:
    """
    Calculates the NIS v2.0 (CDF) score for a single interaction.

    This function implements the full PRODUCTION scoring logic:
    1.  Uses the single, global production CDF pack.
    2.  Calculates s_phys, handling disulfide and vdw special cases.
    3.  Calculates s_kbp, using a geometric mean of valid components.
    4.  Combines s_phys and s_kbp with the alpha-weighted geometric mean.
    5.  Returns a HoriNIS dataclass with the full score and provenance.
    """
    
    # --- 1. Get Fold and CDF Pack (REMOVED) ---
    cdf_pack = CDF_PACK 

    # Ensure KBP manager is available before proceeding
    if kbp_manager is None:
        if _kbp_import_error:
            raise RuntimeError(
                "KBPManager is unavailable because 'hori.kbp_tools' could not be imported."
            ) from _kbp_import_error
        raise ValueError("KBPManager instance is required to compute NIS scores.")

    # --- 2. Set Defaults ---
    alpha = 0.5
    s_phys = 0.5  # Neutral score if data is missing or invalid
    s_kbp = 0.5   # Neutral score if data is missing or invalid

    # --- 3. Physics Score (s_phys) ---
    if phys_energy is not None:
        
        # Disulfide Policy (Spec 6): Always 1.0
        if itype == 'disulfide':
            s_phys = 1.0
        
        else:
            phys_cdf_data = cdf_pack['physics'].get(itype)
            
            # Check if we have a CDF for this physics type
            if phys_cdf_data:
                q_phys = np.array(phys_cdf_data['q'], dtype=np.float32)

                # vdw Adaptive alpha Policy (Req 4)
                if itype == 'vdw':
                    # Use p25 and p75 quantiles. For 401-point P_GRID,
                    # these correspond to indices 100 and 300.
                    iqr = q_phys[300] - q_phys[100]
                    if iqr < 1e-4:  # Check if distribution is flat
                        alpha = 0.0 # Use KBP only

                # Invalid CDF Policy (Req 6)
                if not phys_cdf_data['valid']:
                    s_phys = 0.5  # Set to neutral
                
                # Standard Case: Score from CDF
                else:
                    s_phys = score_from_cdf(phys_energy, q_phys, P_GRID)

    # --- 4. KBP Score (s_kbp) (Req 3) ---
    component_scores: List[float] = []
    components_to_use = KBP_SCHEMA.get(itype)
    
    if components_to_use:
        # Normalize 'hbond_strong'/'weak' to just 'hbond' for KBP lookup
        kbp_lookup_type = 'hbond' if itype.startswith('hbond') else itype
        kbp_type_pack = cdf_pack['kbp'].get(itype)

        if kbp_type_pack:
            for component, metric_key in components_to_use.items():
                
                # Get geometry value (e.g., distance, angle)
                value = kbp_geom_metrics.get(metric_key)
                if value is None:
                    continue # Skip if metric not present

                # Get raw KBP score
                U_kT = kbp_manager.get_potential(kbp_lookup_type, component, value)
                
                # Get the CDF for this specific component
                kbp_comp_cdf_data = kbp_type_pack.get(component)
                
                # Handle Missing/Invalid (Req 3, 6)
                if U_kT is None:
                    continue # Skip if KBP score is None
                if kbp_comp_cdf_data is None:
                    continue # Skip if no CDF was built for this component
                if not kbp_comp_cdf_data['valid']:
                    continue # Skip if CDF is marked invalid (n < 500)
                
                # Standard Case: Score component from its CDF
                q_kbp = np.array(kbp_comp_cdf_data['q'], dtype=np.float32)
                s_comp = score_from_cdf(U_kT, q_kbp, P_GRID)
                component_scores.append(s_comp)

    # Renormalize: Geometric mean of all valid components (Req 3)
    kbp_components_used = len(component_scores)
    if kbp_components_used > 0:
        s_kbp = np.prod(component_scores) ** (1.0 / kbp_components_used)
    # else: s_kbp remains 0.5 (neutral)

    # --- 5. Final Combiner (Spec 5) ---
    # Geometric mean, with alpha weighting
    nis_score = (s_phys ** alpha) * (s_kbp ** (1.0 - alpha))

    # --- 6. Return populated dataclass (Req 2) ---
    return HoriNIS(
        nis_score=float(nis_score),
        s_phys=float(s_phys),
        s_kbp=float(s_kbp),
        nis_mode=_NIS_MODE,          
        alpha_used=float(alpha),
        kbp_components_used=int(kbp_components_used),
        cdf_hash=_CDF_BUILD_HASH,
        kbp_npz_hash=_KBP_NPZ_HASH
    )
